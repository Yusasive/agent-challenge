// Unit tests for Vulnerability Checker Tool
const assert = require('assert');
const { describe, it, before } = require('mocha');

describe('Vulnerability Checker Tool', function() {
  this.timeout(20000);
  
  let vulnerabilityChecker;
  
  before(function() {
    // Mock vulnerability checker
    vulnerabilityChecker = {
      async check(contractCode) {
        const vulnerabilities = [];
        
        // SWC-107: Reentrancy
        if (contractCode.includes('.call(') && !contractCode.includes('nonReentrant')) {
          vulnerabilities.push({
            id: "SWC-107",
            name: "Reentrancy",
            severity: "Critical",
            description: "External call without reentrancy protection",
            remediation: "Use ReentrancyGuard or checks-effects-interactions pattern"
          });
        }
        
        // SWC-115: tx.origin
        if (contractCode.includes('tx.origin')) {
          vulnerabilities.push({
            id: "SWC-115",
            name: "Authorization through tx.origin",
            severity: "Critical",
            description: "Using tx.origin for authorization",
            remediation: "Use msg.sender instead of tx.origin"
          });
        }
        
        // SWC-101: Integer Overflow
        if (contractCode.includes('+') && !contractCode.includes('SafeMath') && !contractCode.includes('pragma solidity ^0.8')) {
          vulnerabilities.push({
            id: "SWC-101",
            name: "Integer Overflow and Underflow",
            severity: "High",
            description: "Arithmetic operations without overflow protection",
            remediation: "Use SafeMath or upgrade to Solidity 0.8.x"
          });
        }
        
        const criticalCount = vulnerabilities.filter(v => v.severity === 'Critical').length;
        const highCount = vulnerabilities.filter(v => v.severity === 'High').length;
        
        let overallRisk = "Low";
        if (criticalCount > 0) overallRisk = "Critical";
        else if (highCount > 0) overallRisk = "High";
        
        return {
          contractName: "TestContract",
          totalVulnerabilities: vulnerabilities.length,
          criticalCount,
          highCount,
          mediumCount: 0,
          lowCount: 0,
          vulnerabilities,
          overallRisk,
          recommendations: ["Implement proper security measures"]
        };
      }
    };
  });
  
  describe('SWC Registry Vulnerabilities', function() {
    it('should detect SWC-107 Reentrancy', async function() {
      const vulnerableCode = `
        function withdraw() public {
          uint amount = balances[msg.sender];
          msg.sender.call{value: amount}("");
          balances[msg.sender] = 0;
        }
      `;
      
      const result = await vulnerabilityChecker.check(vulnerableCode);
      const reentrancy = result.vulnerabilities.find(v => v.id === "SWC-107");
      
      assert(reentrancy, "Should detect reentrancy vulnerability");
      assert.strictEqual(reentrancy.severity, "Critical");
    });
    
    it('should detect SWC-115 tx.origin usage', async function() {
      const vulnerableCode = `
        function authorize() public {
          require(tx.origin == owner);
        }
      `;
      
      const result = await vulnerabilityChecker.check(vulnerableCode);
      const txOrigin = result.vulnerabilities.find(v => v.id === "SWC-115");
      
      assert(txOrigin, "Should detect tx.origin vulnerability");
      assert.strictEqual(txOrigin.severity, "Critical");
    });
    
    it('should detect SWC-101 Integer Overflow', async function() {
      const vulnerableCode = `
        pragma solidity ^0.7.0;
        function add(uint a, uint b) public pure returns (uint) {
          return a + b;
        }
      `;
      
      const result = await vulnerabilityChecker.check(vulnerableCode);
      const overflow = result.vulnerabilities.find(v => v.id === "SWC-101");
      
      assert(overflow, "Should detect integer overflow vulnerability");
      assert.strictEqual(overflow.severity, "High");
    });
  });
  
  describe('Risk Assessment', function() {
    it('should classify critical risk correctly', async function() {
      const criticalCode = `
        function withdraw() public {
          require(tx.origin == owner);
          msg.sender.call{value: 1 ether}("");
        }
      `;
      
      const result = await vulnerabilityChecker.check(criticalCode);
      assert.strictEqual(result.overallRisk, "Critical");
      assert(result.criticalCount > 0);
    });
    
    it('should classify high risk correctly', async function() {
      const highRiskCode = `
        pragma solidity ^0.7.0;
        function calculate(uint a, uint b) public pure returns (uint) {
          return a * b; // Potential overflow
        }
      `;
      
      const result = await vulnerabilityChecker.check(highRiskCode);
      assert.strictEqual(result.overallRisk, "High");
      assert(result.highCount > 0);
    });
    
    it('should classify low risk for secure code', async function() {
      const secureCode = `
        pragma solidity ^0.8.0;
        import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
        
        contract Secure is ReentrancyGuard {
          function withdraw() external nonReentrant {
            // Secure implementation
          }
        }
      `;
      
      const result = await vulnerabilityChecker.check(secureCode);
      assert.strictEqual(result.overallRisk, "Low");
      assert.strictEqual(result.criticalCount, 0);
    });
  });
  
  describe('Vulnerability Counting', function() {
    it('should count vulnerabilities correctly', async function() {
      const multiVulnCode = `
        pragma solidity ^0.7.0;
        function badFunction() public {
          require(tx.origin == owner);
          uint result = a + b;
          msg.sender.call{value: result}("");
        }
      `;
      
      const result = await vulnerabilityChecker.check(multiVulnCode);
      assert(result.totalVulnerabilities >= 2, "Should detect multiple vulnerabilities");
      assert.strictEqual(
        result.totalVulnerabilities,
        result.criticalCount + result.highCount + result.mediumCount + result.lowCount
      );
    });
  });
});