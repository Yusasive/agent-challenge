import { createTool } from "@mastra/core/tools";
import { z } from "zod";

interface Vulnerability {
  id: string;
  name: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  description: string;
  location?: string;
  remediation: string;
  references: string[];
}

interface VulnerabilityReport {
  contractName: string;
  totalVulnerabilities: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  vulnerabilities: Vulnerability[];
  overallRisk: string;
  recommendations: string[];
}

export const vulnerabilityCheckerTool = createTool({
  id: "check-vulnerabilities",
  description: "Performs comprehensive vulnerability assessment using OWASP and SWC registry patterns",
  inputSchema: z.object({
    contractCode: z.string().describe("The Solidity smart contract code to check for vulnerabilities"),
    includeReferences: z.boolean().optional().describe("Whether to include external references and documentation"),
  }),
  outputSchema: z.object({
    contractName: z.string(),
    totalVulnerabilities: z.number(),
    criticalCount: z.number(),
    highCount: z.number(),
    mediumCount: z.number(),
    lowCount: z.number(),
    vulnerabilities: z.array(z.object({
      id: z.string(),
      name: z.string(),
      severity: z.enum(['Critical', 'High', 'Medium', 'Low']),
      description: z.string(),
      location: z.string().optional(),
      remediation: z.string(),
      references: z.array(z.string()),
    })),
    overallRisk: z.string(),
    recommendations: z.array(z.string()),
  }),
  execute: async ({ context }) => {
    return await checkVulnerabilities(context.contractCode, context.includeReferences);
  },
});

const checkVulnerabilities = async (contractCode: string, includeReferences?: boolean): Promise<VulnerabilityReport> => {
  const vulnerabilities: Vulnerability[] = [];
  const lines = contractCode.split('\n');
  
  // Extract contract name
  const nameMatch = contractCode.match(/contract\s+(\w+)/);
  const contractName = nameMatch?.[1] || "UnknownContract";

  // Vulnerability patterns based on SWC Registry and OWASP
  const vulnerabilityChecks = [
    {
      id: "SWC-101",
      name: "Integer Overflow and Underflow",
      pattern: /[\+\-\*\/](?!.*SafeMath)(?!.*pragma\s+solidity\s+\^?0\.[8-9])/,
      severity: 'High' as const,
      description: "Arithmetic operations without overflow protection",
      remediation: "Use SafeMath library or upgrade to Solidity 0.8.x with built-in overflow protection",
      references: ["https://swcregistry.io/docs/SWC-101"]
    },
    {
      id: "SWC-107",
      name: "Reentrancy",
      pattern: /\.call\s*\((?!.*nonReentrant)(?!.*ReentrancyGuard)/,
      severity: 'Critical' as const,
      description: "External call without reentrancy protection",
      remediation: "Implement checks-effects-interactions pattern or use OpenZeppelin's ReentrancyGuard",
      references: ["https://swcregistry.io/docs/SWC-107"]
    },
    {
      id: "SWC-115",
      name: "Authorization through tx.origin",
      pattern: /tx\.origin/,
      severity: 'Critical' as const,
      description: "Using tx.origin for authorization is vulnerable to phishing attacks",
      remediation: "Use msg.sender instead of tx.origin for access control",
      references: ["https://swcregistry.io/docs/SWC-115"]
    },
    {
      id: "SWC-116",
      name: "Block values as a proxy for time",
      pattern: /block\.timestamp|block\.number|now/,
      severity: 'Medium' as const,
      description: "Relying on block values for time-sensitive operations",
      remediation: "Avoid using block.timestamp for critical logic or implement tolerance ranges",
      references: ["https://swcregistry.io/docs/SWC-116"]
    },
    {
      id: "SWC-104",
      name: "Unchecked Call Return Value",
      pattern: /\.call\s*\([^)]*\)\s*;(?!\s*require)/,
      severity: 'High' as const,
      description: "External call return value not checked",
      remediation: "Always check return values of external calls or use require statements",
      references: ["https://swcregistry.io/docs/SWC-104"]
    },
    {
      id: "SWC-106",
      name: "Unprotected SELFDESTRUCT Instruction",
      pattern: /selfdestruct\s*\(/,
      severity: 'High' as const,
      description: "Selfdestruct function without proper access control",
      remediation: "Implement proper access controls and consider the implications of contract destruction",
      references: ["https://swcregistry.io/docs/SWC-106"]
    },
    {
      id: "SWC-114",
      name: "Transaction Order Dependence",
      pattern: /block\.coinbase|block\.difficulty|block\.gaslimit/,
      severity: 'Medium' as const,
      description: "Dependency on block properties that can be manipulated",
      remediation: "Avoid dependencies on manipulable block properties",
      references: ["https://swcregistry.io/docs/SWC-114"]
    },
    {
      id: "SWC-113",
      name: "DoS with Failed Call",
      pattern: /\.transfer\s*\(/,
      severity: 'Medium' as const,
      description: "Using transfer() which can fail with smart contract recipients",
      remediation: "Use call() with proper error handling instead of transfer()",
      references: ["https://swcregistry.io/docs/SWC-113"]
    }
  ];

  // Check each vulnerability pattern
  lines.forEach((line, index) => {
    vulnerabilityChecks.forEach(check => {
      if (check.pattern.test(line)) {
        vulnerabilities.push({
          id: check.id,
          name: check.name,
          severity: check.severity,
          description: check.description,
          location: `Line ${index + 1}: ${line.trim()}`,
          remediation: check.remediation,
          references: includeReferences ? check.references : []
        });
      }
    });
  });

  // Advanced vulnerability checks
  
  // Check for reentrancy vulnerability (more sophisticated)
  if (hasReentrancyVulnerability(contractCode)) {
    vulnerabilities.push({
      id: "SWC-107-ADVANCED",
      name: "Reentrancy Vulnerability",
      severity: 'Critical',
      description: "State changes after external calls detected - classic reentrancy pattern",
      remediation: "Implement checks-effects-interactions pattern: update state before external calls",
      references: includeReferences ? ["https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"] : []
    });
  }

  // Check for access control issues
  if (hasWeakAccessControl(contractCode)) {
    vulnerabilities.push({
      id: "ACCESS-CONTROL",
      name: "Weak Access Control",
      severity: 'High',
      description: "Simple owner-based access control without proper role management",
      remediation: "Use OpenZeppelin's AccessControl or Ownable2Step for robust access management",
      references: includeReferences ? ["https://docs.openzeppelin.com/contracts/4.x/access-control"] : []
    });
  }

  // Check for front-running vulnerabilities
  if (hasFrontRunningRisk(contractCode)) {
    vulnerabilities.push({
      id: "FRONT-RUNNING",
      name: "Front-running Risk",
      severity: 'Medium',
      description: "Transaction ordering dependency detected",
      remediation: "Implement commit-reveal schemes or use private mempools",
      references: includeReferences ? ["https://consensys.github.io/smart-contract-best-practices/attacks/frontrunning/"] : []
    });
  }

  // Count vulnerabilities by severity
  const criticalCount = vulnerabilities.filter(v => v.severity === 'Critical').length;
  const highCount = vulnerabilities.filter(v => v.severity === 'High').length;
  const mediumCount = vulnerabilities.filter(v => v.severity === 'Medium').length;
  const lowCount = vulnerabilities.filter(v => v.severity === 'Low').length;

  // Determine overall risk
  let overallRisk = "Low";
  if (criticalCount > 0) overallRisk = "Critical";
  else if (highCount > 0) overallRisk = "High";
  else if (mediumCount > 2) overallRisk = "Medium";

  // Generate recommendations
  const recommendations = generateRecommendations(vulnerabilities, contractCode);

  return {
    contractName,
    totalVulnerabilities: vulnerabilities.length,
    criticalCount,
    highCount,
    mediumCount,
    lowCount,
    vulnerabilities,
    overallRisk,
    recommendations
  };
};

const hasReentrancyVulnerability = (code: string): boolean => {
  const lines = code.split('\n');
  let inFunction = false;
  let hasExternalCall = false;
  let hasStateChangeAfterCall = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    if (line.includes('function ')) {
      inFunction = true;
      hasExternalCall = false;
      hasStateChangeAfterCall = false;
    }
    
    if (line.includes('}') && inFunction) {
      if (hasExternalCall && hasStateChangeAfterCall) {
        return true;
      }
      inFunction = false;
    }

    if (inFunction) {
      if (/\.call\s*\(|\.send\s*\(|\.transfer\s*\(/.test(line)) {
        hasExternalCall = true;
      }
      
      if (hasExternalCall && /\w+\s*=\s*/.test(line) && !line.includes('require') && !line.includes('assert')) {
        hasStateChangeAfterCall = true;
      }
    }
  }

  return false;
};

const hasWeakAccessControl = (code: string): boolean => {
  const hasOwnerPattern = /owner\s*==\s*msg\.sender|msg\.sender\s*==\s*owner/.test(code);
  const hasOnlyOwner = /onlyOwner/.test(code);
  const hasAccessControl = /AccessControl|Ownable2Step/.test(code);
  
  return hasOwnerPattern && !hasAccessControl && !hasOnlyOwner;
};

const hasFrontRunningRisk = (code: string): boolean => {
  // Check for price-sensitive operations without protection
  const hasPriceLogic = /price|amount|value/.test(code);
  const hasPublicFunction = /function\s+\w+\s*\([^)]*\)\s+public/.test(code);
  const hasCommitReveal = /commit|reveal|hash/.test(code);
  
  return hasPriceLogic && hasPublicFunction && !hasCommitReveal;
};

const generateRecommendations = (vulnerabilities: Vulnerability[], code: string): string[] => {
  const recommendations: string[] = [];
  
  if (vulnerabilities.some(v => v.severity === 'Critical')) {
    recommendations.push("🚨 CRITICAL: Address all critical vulnerabilities immediately before deployment");
  }
  
  if (vulnerabilities.some(v => v.id.includes('SWC-107'))) {
    recommendations.push("Implement reentrancy protection using OpenZeppelin's ReentrancyGuard");
  }
  
  if (vulnerabilities.some(v => v.id.includes('SWC-115'))) {
    recommendations.push("Replace all tx.origin usage with msg.sender for proper access control");
  }
  
  if (!code.includes('pragma solidity ^0.8')) {
    recommendations.push("Upgrade to Solidity 0.8.x for built-in overflow protection and gas optimizations");
  }
  
  if (!code.includes('SPDX-License-Identifier')) {
    recommendations.push("Add SPDX license identifier to comply with best practices");
  }
  
  recommendations.push("Consider implementing a comprehensive test suite with edge cases");
  recommendations.push("Perform additional manual security review and consider professional audit");
  
  return recommendations;
};